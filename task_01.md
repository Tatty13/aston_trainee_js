# Домашняя работа #1

1. Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.

        HTTP-метод `OPTIONS` позволяет клиенту определять опции и/или требования, связанные с ресурсом, или возможностями сервера, но не производя никаких действий над ресурсом и не инициируя его загрузку.

        Основные характеристики:
        - безопасный
        - идемпотентный
        - некешируемый
        - запрос не имеет тела
        - успешный ответ имеет тело

        Использается в качестве предварительного запроса (CORS), помогая браузеру узнать, можно ли осуществить запрос до его обработки.

        В дополнение к заголовкам из простых CORS-запросов (Origin и Access-Control-Allow-Origin) в предварительных запросах браузер прикладывает такие: 
        * Access-Control-Request-Method — указывает метод исходного запроса.
        * Access-Control-Request-Headers — содержит список «небезопасных» заголовков основного запроса, перечисленных через запятую.

        Cервер отвечает с использованием заголовков:
        * Access-Control-Allow-Method — возвращает методы запроса, разрешённые для данного URL.
        * Access-Control-Allow-Headers — возвращает список «небезопасных» заголовков, разрешённых для данного кросс-доменного запроса. Если их несколько, они перечисляются через запятую.

2. Прочитать и описать ключевые особенности "HTTP" Версии 3.0

        Основные особенности вытекают из перехода с протокала TCP на QUIC (Quick UDP Internet Connection):
        * Иначе реализовано мультиплексирование (запросы/ответы передаются параллельно), благодаря чему потеря части пакета не приводит к задержке передачи данных.
        * Сжатие заголовков осуществляется с помощью QPACK.
        * QUIC безопасен по умолчанию, что делает соединению всегда шифрованным, а также позволяет быстрее делать первоначальное соединение (вместо трёхстороннего рукопожатия TCP и TLS - трёхстороннее рукопожатие только QUIC).
        * При разрыве соединения не нужно устанавливать новое, то есть не будет повторных рукопожатий, так как используется уникальный идентификатор соединения
        * QUIC также шифрует метаданные о соединении.
        * Добавлен механизм миграции соединения (позволяет поддерживать активное соединение, даже если меняется сеть или  IP-адрес устройства)

3. Прочитать про способы отмены запроса, включая объект "AbortController"

        AbortController - интерфейс, позволяющий оборвать один и более запросов. Свойство signal передаётся в fetch, метод abort() прерывает запрос.

        В Axios нужно сгенерировать токен отмены:
            const cancelToken = axios.CancelToken;
            const source = cancelToken.source();
        Этот источник затем передается в запрос axios:
            const { data } = await instance.get("/", {
              cancelToken: source.token,
            });
        Источник содержит метод cancel, который можно вызвать для отмены запроса:
            source.cancel("axios request cancelled");

        Метод abort() в XMLHttpRequest:
            const xhr = new XMLHttpRequest();
            xhr.send();
            xhr.abort();

        Если используется WebSocket, то можно закрыть соединение методом close():
            const socket = new WebSocket('url');
            socket.close();

4. Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

      ```javascript
        const num1 = 1; // 1
        const num2 = Number(2); // 2

        const str1 = 'string'; // 'string'
        const str2 = String(2); // '2'

        const boolean1 = true; // true
        const boolean2 = Boolean('') // false

        const null1 = null // null

        const undefined1 = undefined; // undefined
        let undefined2; // undefined

        const bigInt = 10n // 10n
        const bigInt2 = BigInt(10) // 10n

        const symbol1 = Symbol('check') // Symbol('check')

        ```

5. Почему, если обратиться к переменным созданным через let/const до их объявления, мы получаем ReferenceError?

        Потому что во время инициализации они попадают во временную мёртвую зону и не видны интерпретатору до их объявления.

6. Решить:

      ```javascript
        const res = "B" + "a" + (1 - "hello");
        console.log(res); //'BaNaN'

        const res2 = (true && 3) + "d";
        console.log(res2); //'3d'

        const res3 = Boolean(true && 3) + "d";
        console.log(res3); //'trued'

        ```
