# Домашняя работа #4

1. **Какие бывают алгоритмы сортировок?**

    * `Bubble sort (Пузырьковая сортировка)` - асимптотика в худшем и среднем случае – O(n2), в лучшем случае – O(n).

    * `Selection sort (Сортировка выбором)` - асимптотика O(n2) в лучшем, среднем и худшем случае.

    * `Insertion sort (Сортировка вставками)` - асимптотика в среднем и худшем случае – O(n2), в лучшем – O(n).

    * `Merge sort (Сортировка слиянием)` - слияние работает за O(n), уровней всего logn, поэтому асимптотика O(nlogn). Эффективно заранее создать временный массив и передать его в качестве аргумента функции.

    * `Heap sort (Пирамидальная сортировка/Сортировка кучей)` - асимптотика O(nlogn) в худшем, среднем и лучшем случае.

    * `Quick sort (Быстрая сортировка)` - асимптотика O(nlogn) в среднем и лучшем случае, O(n2). Наихудшая оценка достигается при неудачном выборе опорного элемента.

    * `Shaker sort (Шейкерная сортировка)` - асимптотика у алгоритма такая же, как и у сортировки пузырьком, однако реальное время работы лучше.

    * `Comb sort (Сортировка расческой)` - в лучшем случае асимптотика равна O(nlogn), в худшем – O(n2).

    * `Tree sort (Сортировка деревом)` - асимптотика будет равна O(nlogn) в худшем, среднем и лучшем случае.

    * `Gnome sort (Гномья сортировка)` - алгоритм похож на сортировку вставками. Поддерживаем указатель на текущий элемент, если он больше предыдущего или он первый — смещаем указатель на позицию вправо, иначе меняем текущий и предыдущий элементы местами и смещаемся влево.

2. **Прочитать про "Операторы и выражения, циклы в JS"**

    `ОПЕРАТОРЫ:`

    Оператор - это символы или ключевые слова, которые указывают движку JavaScript на выполнение каких-либо действий.

    Оператор – это внутренняя функция JavaScript.

    |По количеству операндов||
    |:-|-:|
    |`Унарные`| `+` (приведение к числу), `-` (противоположное число), `++` , `delete`, ...|
    |`Бинарные`|`===`, `+` (сложение), ...|
    |`Тернарные`|`? :`|
    |||

    |По внешнему представлению| |
    |:-|-:|
    |`символьные`| `*`, `!` `<<`, ...|
    |`текстовые`| `instanceof`, `delete`, `new`, `typeof`, `void` (определяет выражение, которое должно быть вычислено без возвращения результата), `break`, ...|
    |||

    |По функции| |
    |:-|-:|
    |`Присваивания`| `=`, `+=`, `-=`, `%=`, `\|\|=`, ...|
    |`Cравнения`|`==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`.
    |`Арифметические`| `+` (унарный и бинарный), `-` (унарный и бинарный), `*`, `/`, `%`, `**`, `++`, `--`
    |`Логические`| `&&`, `\|\|`,`!`,`??` (оператор нулевого слияния)|
    |`Строковые`| операторы сравнения, бинарный `+`, `+=`|
    |`Битовые (поразрядные)`|`~` ('не'),  `<<`, `>>`, `>>>` (сдвиг вправо с заполнением нулями), `&` (возвращает единицу в каждой битовой позиции, для которой соответствующие биты обеих операндов являются единицами), `^` (возвращает единицу в каждой битовой позиции, для которой только один из соответствующих битов операндов является единицей) и др.
    |`Операторы отношения` - сравнивает свои операнды и возвращает результат сравнения в виде булева значения|`in` (возвращает `true`, если указанный объект имеет указанное свойство), `instanceof` - возвращает true, если заданный объект является объектом указанного типа.
    |`Удаления`|`delete` - выполняет удаление объекта, свойства объекта, или элемента массива с заданным индексом, а так же переменных, объявленных неявно. Возвращает `true` если выполнение операции возможно, иначе - `false`.
    |`Создания объекта`| `new`|
    |`Группировки`|`( )`|
    |`Оператор запятая`|`,` - вычисляет оба операнда и возвращает значение последнего|
    |||

    `ВЫРАЖЕНИЯ:`

    Выражение - любой корректный блок кода, который возвращает значение.

    Концептуально, существуют два типа выражений:
    * те которые `присваивают` значение переменной: `x = 7`
    * те, которые `вычисляют` значение `без` его `присваивания`: `3 + 4`

    Категории выражений:
    |||
    |:-|-:|
    |`Арифметические`| вычисляются в число, используют арифметические операторы|
    |`Строковые`|  вычисляются в текстовую строку, используют строковые операторы|
    |`Логические`| вычисляются в true или false, используют логические операторы|
    |`Основные`| базовые ключевые слова (`this`) и основные выражения в JavaScript|
    |`Левосторонние`| значениям слева назначаются значения справа|
    |||

    `ЦИКЛЫ:`

    Цикл — это повторяющаяся последовательность действий.\
    Цикл состоит из условия и тела цикла.

      * `for` - для выполнения блока кода заданное количество раз.
      * `while` - для выполнения блока кода пока заданное условие остается истинным.
      * `do ... while` - выполнится минимум 1 раз, далее выполняется, пока заданное условие остается истинным.
      * `for ... in` - для итерации свойств объекта, проходит по именам свойств. В цикле будут перечислены не только собственные свойства объекта, но и все перечисляемые свойства из прототипа объекта и прототипа прототипа и т.д.
      * `for ... of` - для перебора итерируемых сущностей, проходит по значениям свойств

3. Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.

    ```javascript
    // создание объекта person - литеральный способ
    const person = {
      name: 'Vasya',
      age: 23,
    }

    // создание объекта person - конструктор
    const person = new Object({
      name: 'Vasya',
      age: 23,
    })

    // создание объекта person - класс
    class Person {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }
    }
    const person = new Person('Vasya', 23);

    // создание объекта person2 - литеральный способ
    const person2 = {
      name: 'Any',
      age: 24,
      __proto__: person,
    }

    // создание объекта person2 - метод Object.create
    const person2 = Object.create(person, {
      name: {value: 'Any', enumerable: true, writable: true, configurable: true},
      age: {value: 24, enumerable: true, writable: true, configurable: true},
    });

    // метод logInfo будет доступен объекту person и его наследникам
    person.logInfo = function() {
      return `Name: ${this.name}. Age: ${this.age}.`;
    }

    // определение метода logInfo с помощью метода defineProperty
    Object.defineProperty(person, 'logInfo', {
      value: function() {
        return `Name: ${this.name}. Age: ${this.age}.`;
      },
      configurable: true,
    });

    // метод logInfo будет доступен всем объектам
    Object.prototype.logInfo = function() {
      return `Name: ${this.name}. Age: ${this.age}.`;
    }

    /* --------------- пример --------------- */
    console.log(person.logInfo()); // Name: Vasya. Age: 23.
    console.log(person2.logInfo()); // Name: Any. Age: 24.
    ```

4. Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.

    ```javascript
    // вариант 1
    class Person {
      constructor(name, age) {
        this._name = name;
        this._age = age;
      }

      logInfo() {
        return `Name: ${this._name}. Age: ${this._age}.`;
      }
    }

    class PersonThree extends Person {
      constructor(name, age) {
        super(name, age);
      }
      
      get name() {
        return this._name;
      }

      set name(value) {
        this._name = value;
      }
    }

    // вариант 2
    class Person {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }

      logInfo() {
        return `Name: ${this.name}. Age: ${this.age}.`;
      }
    }

    class PersonThree extends Person {
      constructor(name, age) {
        super(name, age);
      }
      
      get name() {
        return super.name;
      }

      set name(value) {
        super.name = value;
      }
    }

    const person3 = new PersonThree('Vasya', 20);
    console.log(person3.name) // Vasya
    person3.name = 'Petya'
    console.log(person3.name) // Petya

    ```

5. Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total. Какая сложность у вашего алгоритма?

    ```javascript
    // сложность алгоритма On^2
    const firstSum1 = (arr: number[], total: number) => {
      for (let i = 0; i < arr.length; i++) {
        const firstNum = arr[i];

        for (let j = i + 1; j < arr.length; j++) {
          const secondNum = arr[j];
          if (firstNum + secondNum === total) return [firstNum, secondNum];
        }
      }
      return 'No such sum';
    };

    // сложность алгоритма On^2
    const firstSum2 = (arr: number[], total: number) => {
      for (let i = 0; i < arr.length; i++) {
        const firstNum = arr[i];
        const requiredNum = total - firstNum;
        if (arr.includes(requiredNum, i+1)) return [firstNum, requiredNum];    
      }
      return 'No such sum'
    }

    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    total = 13;
    firstSum1(arr,total) // [4, 9]

    ```
