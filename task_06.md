# Домашняя работа #6

1. **Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода**

    * `KISS` - Keep It Simple, Stupid

      Принцип проектирования, принятый в военно-морских силах США в 1960. Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей и следует избегать ненужной сложности.

      Не придумывать к задаче более сложного решения, чем ей требуется.
      Чем проще код, тем легче в нём разобраться. Под простотой подразумевается отказ от использования хитроумных приемов и ненужного усложнения.

    * `DRY` - Don’t Repeat Yourself

      Всё, что пишется в проекте, должно быть определено только один раз. При несоблюдении этого принципа программист будет вынужден вносить изменения в несколько повторяющихся фрагментов кода, вместо одного. Также дублирующийся код приводит к разрастанию программы, а значит, усложняет ее понимание, читабельность.

    * `YAGNI` - You Aren’t Gonna Need It

      Не стоит писать функциональность наперед, если прямо сейчас в ней нет необходимости. Желание написать код на будущее может иметь много неприятных последствий:
      * Вы тратите драгоценное время, которое могло бы быть использовано на добавление, тестирование и улучшение действительно необходимой функциональности.
      * Новые функции должны быть протестированы, задокументированы.
      * Ваши ненужные новые функции могут впоследствии помешать добавить новые, но уже нужные.
      * Если написанный код в итоге понадобится, он может оказаться неправильным.
      * Лишний код может в итоге никогда и не понадобиться.
      * Лишний код усложняет вашу программу (см. KISS).
      * Добавление новой ненужной функциональности может привести к желанию добавить ещё больше новой лишней функциональности, приводя к эффекту «снежного кома».

    * `Антипаттерны чистого кода`

      * Преждевременная оптимизация

        Сначала профилирование, потом оптимизация. Не меняйте простоту на эффективность, пока об этом не заявят эмпирически полученные данные.

      * Магические числа и строчки

        Без поясняющего имени семантика числа или строки скрыта от нас. Это усложняет понимание кода, а необходимость поменять константу может привести к ошибкам.

      * Спагетти-код

        Сложный и запутанный код, который трудно отладить или изменить. Читаемость такого кода очень низкая, и, как правило, практически невозможно понять, как именно он работает.

      * Изобретение колеса

        Когда мы хотим сделать все сами и написать всё с нуля, не ища уже существующие методы, API или библиотеки.

      * Ад зависимости

        Противоположность изобретению колеса. Если вместо того, чтобы писать все с нуля, мы используем слишком много сторонних библиотек, которые полагаются на конкретные версии других библиотек.

      * Trailing whitespaces

        Пробелы в конце строки являются излишними, к тому же они усложняют commit-изменения в Github (вы видите лишнюю строчку/символ изменений, не несущего смыслового изменения).

      * Лодочный якорь (Boat Anchor)

        Когда программисты оставляют неиспользуемый код в базе, потому что он может понадобиться им позже.

      * Мертвый код / Поток лавы (Lava Flow)

        Код, который был когда-то написан, но на данный момент необходимости в нём нет.

        Код, который имеет избыточные или некачественные части, которые кажутся неотъемлемой частью программы, но мы не до конца понимаем, что он делает или как он влияет на все приложение. Это делает рискованным удаление. Это обычно происходит с устаревшим кодом, или когда код был написан кем-то другим (обычно без надлежащей документации), или когда проект слишком быстро перешел с этапа разработки на этап производства.

      * Разрастание кода (The Proliferation of Classes)

        Когда в кодовой базе есть объекты, существующие исключительно для вызова других, более важных объектов. То есть это объекты-посредники в чистом виде.

      * Божественный объект / Швейцарский нож (God Object)

        Божественные объекты делают слишком много.

2. **Прочитать про способы хранения LocalStorage, SessionStorage и Cookie**

    * `Local Storage`

      Реализация Web Storage (интерфейса взаимодействия с хранилищем).

      Данные хранятся в формате ключ-значение. Значения хранятся в виде строк. При попытке сохранения других типов данных, они будут приведены к строке.

      Максимальный объем хранимых данных — `5 Мб`.

      В теории, является бессрочным хранилищем данных. Хотя данные и должны храниться бессрочно, браузеры все равно вводят свои ограничения.

      При переполнении хранилища оно полностью очищается.
      Safari очищает Local Storage если к нему не обращались в течение семи дней.

    * `Session Storage`

      Похож на LocalStorage, но данные хранятся только в течение сессии.

      Сессия страницы создаётся при открытии новой вкладки браузера. Сессия остаётся активной до тех пор, пока открыта вкладка, а состояние сессии сохраняется между перезагрузками. Открытие новой вкладки с таким же адресом приведёт к созданию новой сессии.

    * `Cookie`

      Данные, хранящиеся в куках, также передаются на сервер в виде HTTP-заголовка и могут быть им изменены.

      Куки передаются при каждом запросе к серверу.
      Их размер ограничен `4096 байтами` (4 Кб).
      В содержимом не должно быть пробелов или запятых, оно должно быть закодировано и быть безопасным, чтобы не сломать отправляемый запрос.

      Куки не являются постоянным хранилищем, срок хранения данных по умолчанию ограничен длинной сессии, и для продления хранения кук используется дополнительный параметр.

      Как правило, этим способом пользуются для хранения авторизационных данных или когда доступ к записанным данным нужен на сервере. Ещё куки используются для отслеживания поведения пользователя на сайте.

      Все куки хранятся в свойстве `document.cookie`. Это свойство представляет собой строку в формате имя=значение, где пары имён и значений разделяются знаком `;` . Если присвоить document.cookie новое значение, то оно не заменит полностью старую строку, а добавит или изменит значение по ключу.

3. **HTML / CSS - Базовая структура html документа, БЭМ методология**

    ```html
    <!-- Указывает браузеру, какой стандарт HTML используется в этом документе (в данном случае HTML5) -->
    <!DOCTYPE html>
     <!--Тег html сообщает браузер, где начинается контент, который необходимо обработать как HTML. Атрибута lang указывает язык, на котором отображается веб-страница. -->
    <html lang="ru">
      <!-- Тег <head> служит для хранения метаданных (название страницы, описание, ключевые слова и т.д.). -->
      <head>
        <!-- Устанавливает кодировку документа -->
        <meta charset="UTF-8">
        <!-- Устанавливает ширину области просмотра равной ширине экрана -->
        <meta name="viewport" content="width=device-width">
        <!-- Заголовок страницы -->
        <title>Моя первая страница</title>
      </head>
      <!--Тег <body> вмещает отображаемый контент -->
      <body></body>
    </html>

    ```

    `БЭМ` (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».

    В CSS по БЭМ также не рекомендуется использовать селекторы по тегам или id.

      * `Блок` - функционально независимый компонент страницы, который может быть повторно использован.

        Название блока характеризует смысл («что это?» — «меню»: menu, «кнопка»: button), а не состояние («какой, как выглядит?» — «красный»: red, «большой»: big).

        Блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование.

        ```html
        <div class="error"></div>
        ```

      * `Элемент` - cоставная часть блока, которая не может использоваться в отрыве от него.

        Название элемента характеризует смысл, а не состояние.

        Структура полного имени элемента соответствует схеме: `имя-блока__имя-элемента`. Имя элемента отделяется от имени блока двумя подчеркиваниями (`__`).

        ```html
        <!-- Блок `search-form` -->
        <form class="search-form"> 
        <!-- Элемент `input` блока `search-form` -->
        <input class="search-form__input">

        <!-- Элемент `button` блока `search-form` -->
        <button class="search-form__button">Найти</button>
        </form>
        ```

      * `Модификатор` - cущность, определяющая внешний вид, состояние или поведение блока либо элемента.

        Название модификатора характеризует внешний вид («какой размер?», «какая тема?» и т. п. — «размер»: size_s, «тема»: theme_islands), состояние («чем отличается от прочих?» — «отключен»: disabled, «фокусированный»: focused) и поведение («как ведет себя?», «как взаимодействует с пользователем?» — «направление»: directions_left-top).

        Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (`_`).

        Модификатор нельзя использовать самостоятельно.

        Могут быть двух типов: `булевый` и `ключ-значение`.

        ```html
        <!-- Блок `search-form` имеет булевый модификатор `focused` -->
        <form class="search-form search-form_focused">

          <!-- Элемент `button` имеет булевый модификатор `disabled` -->
          <button class="search-form__button search-form__button_disabled">Найти</button>
        </form>


        <!-- Блок `search-form` имеет модификатор `theme` со значением `islands` -->
        <form class="search-form search-form_theme_islands">
          <input class="search-form__input">

          <!-- Элемент `button` имеет модификатор `size` со значением `m` -->
          <button class="search-form__button search-form__button_size_m">Найти</button>
        </form>
        ```

4. **Почитать про паттерны функционального программирования + посмотреть примеры использования**

    В основе функционального программирования — чистые функции и неизменяемые структуры данных.
    Функция - это элемент композиции.

    * Чистые функции (Pure Functions):

      Чистая функция не имеет побочных эффектов, она зависит только от своих входных параметров и всегда возвращает одинаковый результат для одних и тех же входных данных.
      Пример: function add(a, b) { return a + b; }

    * Функции высшего порядка (Higher-Order Functions):

        Функции, которые принимают другие функции в качестве аргументов или возвращают их как результат, называются функциями высшего порядка.
        Пример: map, filter, reduce.

    * Каррирование (Currying):

        Процесс преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает только один аргумент.
        Пример: const add = a => b => a + b;

    * Рекурсия (Recursion):

      Замена циклов в функциональном программировании. Функция вызывает саму себя для решения задачи.
      Пример: Функция для вычисления факториала.

    * Неизменяемость (Immutability):

      Использование неизменяемых (immutable) структур данных, чтобы избежать изменений в состоянии программы.
      Пример: Использование методов, таких как map или filter, для создания новых массивов вместо изменения существующих.

    * Функции композиции (Function Composition):

      Комбинирование нескольких функций в одну, чтобы выполнить последовательную обработку данных.
      Пример: const composedFunction = compose(func1, func2, func3);

    * Мемоизация (Memoization):

      Сохранение результатов выполнения функции для определенных входных данных и повторное использование их при последующих вызовах функции с теми же входными данными.
      Пример: Использование кэширования для улучшения производительности.

    * Замыкания (Closures):

      Функции, которые запоминают окружение, в котором они были созданы, и могут обращаться к переменным из этого окружения, даже после того как это окружение вышло из области видимости.
      Пример: Функции, возвращающие другие функции.

    * Функции-генераторы (Generator Functions):

      Функции, которые могут быть приостановлены и возобновлены в процессе выполнения, что позволяет лениво генерировать последовательности данных.
      Пример: Генераторы в JavaScript.

5. **Способы позиционирования контента на странице**

    * inherit
    * static - значение по умалчанию
    * relative
    * absolute
    * fixed
    * sticky

6. **Веса селекторов**

    Типы селекторов по убыванию специфичности:

    1. Селекторы по id (`#title`);
    2. Селекторы по классу (`.title`), атрибуту (`[type="radio"]`) и селекторы с псевдоклассами (`:hover`);
    3. Селекторы по тегу (`h1`), селекторы с псевдоэлементами (`::before`).

    Комбинаторы `+`, `>`, `~`, универсальный селектор `*` и псевдокласс `:where()` веса не имеют.

    Псевдоклассы `:is()`, `:has()` и `:not()` принимают вес наиболее специфичного селектора внутри скобок.

    CSS-свойства, написанные в атрибуте `style` внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега `<style>`.

    Ключевое слово `!important` нарушает естественную работу специфичности и каскада, насильно применяя свойство, после которого написано. Если к элементу применимы два взаимоисключающих стиля с модификатором `!important`, то применён будет стиль с большей специфичностью.
